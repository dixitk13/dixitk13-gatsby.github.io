{"data":{"blogs":{"edges":[{"node":{"id":"9a06a21e-6482-51f8-aaea-f167925f67ed","html":"<p>I believe in making small pull requests and they can be either of features, bug fixes, changes/updates and improvements.</p>\n<p>I've always felt that need to entitle my PR's with:</p>\n<ul>\n<li>\n<p><code>[DO-NOT-MERGE]</code>:</p>\n<ul>\n<li>When i need to show it to my folks and get opinions or ideas and not having to send it out in an email/slack message.</li>\n<li>Or when I need to get it reviewed from other managers out there if the behavior is finally what they asked for.</li>\n<li>Or I need a build out prod version of my code</li>\n</ul>\n</li>\n<li>\n<p><code>[NEEDS-TESTING]</code>: when I've finished writing the code:</p>\n<ul>\n<li>but its 12am</li>\n<li>or maybe my codebase lacks e2e for all the other code surrounding mine.\nP.S: lets face it guys not everyone has strong e2e and pushes at 12 am, sets to auto-complete and sleeps the night.</li>\n</ul>\n</li>\n</ul>\n<p><code>[DRAFT]</code> is my rescuer here where any teammate isn't going to click merge/approve and call it a day but is definately going to have a look to leave out comments to chime and continue the discussions</p>\n<p>Ref: <a href=\"https://github.blog/2019-02-14-introducing-draft-pull-requests/\">https://github.blog/2019-02-14-introducing-draft-pull-requests/</a></p>\n<h2>What I follow as nomenclature for Pull Requests:</h2>\n<p>Most of my PR's follow a nomenclature for branch naming as well, call me victim of OCD but that's me!</p>\n<ul>\n<li><code>&#x3C;username>/hotfix/&#x3C;branch-code-name></code> : for hot-fixes of course</li>\n<li><code>&#x3C;username>/changes/&#x3C;branch-code-name></code> : for changes/improvements</li>\n<li><code>&#x3C;username>/feature/&#x3C;branch-code-name></code>: for feature updates</li>\n</ul>\n<p>where branch code name is an at-most 3 letter word for what the branch is doing. I try not to name them like with prefix of an issue number since I am bad with numbers, but if you are that's the best way to do your nomenclature TBH.</p>\n<p>I usually try to keep my commit messages short, so its readable in single line - about 50 or less should do it. If you'd like to write more text, after the 50 lines a new line should be added and rest of the text should be wrapped at 72 lines-ish.</p>\n<p>A good read about how I adopted the above <a href=\"https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html\">here</a></p>\n<p>Some argue making the commit message like a summary helps them the below for sending (nicely formatted emails)[https://thoughtbot.com/blog/send-a-patch-to-someone-using-git-format-patch], but meh - email's not going to live long hopefully.</p>\n<pre><code>git format-patch &#x3C;branch> --stdout\n</code></pre>\n<p>Adopt <strong>rebase</strong>. It seems to keep the history clean, coming from the <strong>merge</strong> guy who used merge for several years now :)</p>","frontmatter":{"path":"/draft-pull-requests","type":"blog","date":"2020-05-10","title":"Draft pull requests"},"excerpt":"I believe in making small pull requests and they can be either of features, bug fixes, changes/updates and improvements. I've always felt t…"}},{"node":{"id":"98e6f2f0-8799-535c-bf2d-8336499499f7","html":"<p>Very often we have use-cases where we would like to use a single type <code>Union Type</code> but still be sure about the properties inside them.</p>\n<pre><code class=\"language-{javascript}\">interface Employee {\n  name: string;\n    salary: number;\n}\n\ninterface HumanResource {\n  name: string;\n  power: boolean;\n}\n\nlet person: Employee | HumanResource;\n</code></pre>\n<p>But under the hood Typescript union's are more of \"common\" properties inside them instead of \"having all the properties\".</p>\n<p>So when you try and use it like:</p>\n<pre><code class=\"language-{javascript}\">let helloPerson = (person: Employee | HumanResource): void => {\n   console.log(person.&#x3C;only has properties common to Employee &#x26; HumanResource aka name>);\n}\n</code></pre>\n<p>where as you would expect person to have <code>{name, salary}</code> or <code>{name, power}</code> and choose between them depending on what person is.</p>\n<p>This is where discriminators come in power-play. Bear with my variable nomenclature:</p>\n<p>Lets define an enum to contain both the use-cases of Person's we have, calling it <code>PersonType</code> and then define a type combining <code>HumanResource</code> and <code>Employee</code>.</p>\n<pre><code class=\"language-{javascript}\">enum PersonType { \"EMPLOYEE\" , \"HR\" }\n\ninterface Employee {\n  name: string;\n  type: PersonType.EMPLOYEE\n    salary: number;\n}\n\ninterface HumanResource {\n  name: string;\n  type: PersonType.HR\n  power: boolean;\n}\n\ntype Person = HumanResource | Employee;\n\nlet person: Employee | HumanResource;\n\nlet helloPerson = (person: Person): void => {\n  switch(person.type) {\n    case PersonType.EMPLOYEE:\n      // this gives you both name/salary since now TS understands\n      // and discriminates between the two types you have\n      console.log(person.{gives you name, salary});\n  }\n}\n</code></pre>","frontmatter":{"path":"/typescript-discriminator","type":"blog","date":"2020-04-10","title":"Typescript discriminator"},"excerpt":"Very often we have use-cases where we would like to use a single type Union Type but still be sure about the properties inside them. But un…"}}],"totalCount":2}}}