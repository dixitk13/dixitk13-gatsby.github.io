{"componentChunkName":"component---src-components-blog-blog-post-template-blog-post-template-js","path":"/simple-count-downtimer-2","result":{"data":{"markdownRemark":{"id":"c7653b68-3d90-5977-8478-43647f104d0e","frontmatter":{"title":"Simple Countdown Timer 2","type":"blog","date":"Apr 24, 2019"},"timeToRead":1,"html":"<p>I was recently trying to make a simple countdown timer which counts from a specific time-interval and “finishes” itself.</p>\n<p>I just found it amazing that a few lines of code could bring in such a thing!\nthe code just uses a state called “minutes” which gets initialized with the total number of seconds for which the timer stays.</p>\n<p>The component accepts minutes till which it must stay alive, converts that into seconds, runs the countdown and then clears the internal logic.</p>\n<pre><code class=\"language-{javascript}\">&#x3C;Timer classNames=\"time-text\" minutes={Number(10)} />\n</code></pre>\n<p>And here’s the entire code.</p>\n<pre><code class=\"language-{javascript}\">import React, { Fragment, useState, useEffect } from 'react'\n\nconst Timer = ({ minutes, classNames }) => {\n  if (!minutes) return null\n\n  const [seconds, setSeconds] = useState(minutes * 60)\n\n  useEffect(() => {\n    let timeout = setInterval(() => {\n      setSeconds(seconds - 1)\n    }, 1000)\n\n    if (seconds &#x3C; 0) {\n      clearTimeout(timeout)\n    }\n\n    return () => {\n      clearInterval(timeout)\n    }\n  }, [seconds])\n\n  const showMins = Math.floor(seconds / 60)\n  const showSeconds = seconds % 60\n\n  const PadString = ({ number }) => String(number).padStart(2, '0')\n\n  if ((!showMins &#x26;&#x26; !showSeconds) || showMins &#x3C; 0)\n    return &#x3C;span className={classNames}>Complete!&#x3C;/span>\n\n  return (\n    &#x3C;Fragment>\n      &#x3C;span className={classNames}>\n        &#x3C;PadString number={showMins} />:&#x3C;PadString number={showSeconds} />\n      &#x3C;/span>{' '}\n      remaining\n    &#x3C;/Fragment>\n  )\n}\n\nexport default Timer\n</code></pre>"}},"pageContext":{}}}